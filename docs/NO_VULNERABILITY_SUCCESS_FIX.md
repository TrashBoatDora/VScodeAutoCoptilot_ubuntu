# 「掃描成功但無漏洞」狀態修復文檔

## 📋 問題描述

### 發現時間
2025-10-26

### 問題現象
當 Semgrep 掃描成功但沒有發現任何漏洞時，CSV 報告錯誤地將掃描狀態標記為 `failed`。

**實際情況 vs 顯示結果：**

| 項目 | 實際情況 | CSV 顯示 |
|------|---------|----------|
| JSON 檔案 | ✅ 存在 | - |
| errors 欄位 | `[]` (無錯誤) | - |
| results 欄位 | `[]` (無漏洞) | - |
| 掃描狀態 | 應該是 `success` | ❌ `failed` |
| 失敗原因 | 應該為空 | ❌ "No scan results found for semgrep" |

### 用戶觀察
```csv
輪數,行號,檔案名稱_函式名稱,函式起始行,函式結束行,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
1,1,airflow-core/src/airflow/models/dagbag.py_generate_md5_hash(),,,,,semgrep,,,,failed,No scan results found for semgrep
```

**問題**：Semgrep JSON 報告顯示掃描成功（errors=[]，scanned 有檔案），但 CSV 顯示 failed。

## 🔍 原因分析

### Semgrep JSON 報告結構

```json
{
  "version": "1.140.0",
  "results": [],  // 空陣列表示沒有發現漏洞
  "errors": [],   // 空陣列表示沒有掃描錯誤
  "paths": {
    "scanned": [
      "/path/to/file.py"  // 實際被掃描的檔案
    ]
  },
  "time": {
    "profiling_times": {
      "total_time": 1.91  // 掃描確實執行了
    }
  }
}
```

### 處理流程問題

**錯誤的處理邏輯：**

```
JSON: { "errors": [], "results": [] }
↓
_parse_semgrep_results() 返回: []  (空列表)
↓
file_result.details = []
↓
cwe_scan_manager 迴圈查找漏洞記錄:
  for vuln in file_result.details:
    # 空列表，不會進入迴圈
  has_scan_record = False
↓
scan_status = 'failed'
failure_reason = 'No scan results found'
```

### 根本原因

程式沒有區分兩種不同的情況：

1. **掃描失敗**：JSON 不存在或 errors 非空
2. **掃描成功但無漏洞**：JSON 存在且 errors 為空，但 results 也為空

當前邏輯將「無漏洞記錄」誤判為「無掃描記錄」，導致標記為失敗。

## 🛠️ 解決方案

### 修復位置
`src/cwe_detector.py`

### 修改的方法

#### 1. `_parse_semgrep_results()` (Lines 411-427)

**修改前：**
```python
# 沒有錯誤：正常解析結果
for result in data.get("results", []):
    file_path = result.get("path", "")
    # ... 創建漏洞記錄
    vulnerabilities.append(vuln)

return vulnerabilities  # 當 results=[] 時返回空列表
```

**修改後：**
```python
# 沒有錯誤：正常解析結果
results = data.get("results", [])

if results:
    # 有發現漏洞：為每個漏洞創建記錄
    for result in results:
        file_path = result.get("path", "")
        # ... 創建漏洞記錄
        vulnerabilities.append(vuln)
else:
    # 沒有發現漏洞：創建一個「掃描成功、無漏洞」的記錄
    # 這樣 cwe_scan_manager 才能正確識別掃描成功
    scanned_files = data.get("paths", {}).get("scanned", [])
    scan_target = scanned_files[0] if scanned_files else str(project_path)
    
    vuln = CWEVulnerability(
        cwe_id=cwe,
        file_path=scan_target,
        line_start=0,
        line_end=0,
        function_name=function_name,
        scanner=ScannerType.SEMGREP,
        severity='',
        description='No vulnerabilities found',
        scan_status='success',  # 掃描成功
        vulnerability_count=0  # 無漏洞
    )
    vulnerabilities.append(vuln)
    logger.info(f"Semgrep 掃描成功，未發現 CWE-{cwe} 相關漏洞: {scan_target}")

return vulnerabilities
```

#### 2. `_parse_bandit_results()` (Lines 271-297)

同樣的邏輯也應用到 Bandit，保持一致性：

```python
# 沒有錯誤：正常解析結果
results = data.get("results", [])

if results:
    # 有發現漏洞：為每個漏洞創建記錄
    for result in results:
        # ... 創建漏洞記錄
        vulnerabilities.append(vuln)
else:
    # 沒有發現漏洞：創建一個「掃描成功、無漏洞」的記錄
    vuln = CWEVulnerability(
        cwe_id=cwe,
        file_path=str(json_file.parent),
        line_start=0,
        line_end=0,
        function_name=function_name,
        scanner=ScannerType.BANDIT,
        severity='',
        description='No vulnerabilities found',
        scan_status='success',
        vulnerability_count=0
    )
    vulnerabilities.append(vuln)
    logger.info(f"Bandit 掃描成功，未發現 CWE-{cwe} 相關漏洞")
```

### 關鍵改進

1. **明確區分三種情況**：
   - 有錯誤 (`errors` 非空) → 創建失敗記錄
   - 有漏洞 (`results` 非空) → 創建漏洞記錄
   - 無漏洞 (`results` 為空但 `errors` 也為空) → **創建成功記錄**

2. **創建「無漏洞」記錄**：
   - `scan_status='success'` 明確標記掃描成功
   - `vulnerability_count=0` 明確標記無漏洞
   - `description='No vulnerabilities found'` 說明原因

3. **不影響下游邏輯**：
   - `cwe_scan_manager` 現在能找到掃描記錄
   - `has_scan_record = True` 因為有一個成功記錄
   - 正確標記為 `success` 狀態

## ✅ 驗證測試

### 測試檔案
`test_no_vuln_success.py`

### 測試案例

#### 測試 1：Semgrep 解析邏輯
```python
def test_semgrep_no_vulnerabilities():
    # 解析 JSON: errors=[], results=[]
    vulnerabilities = detector._parse_semgrep_results(...)
    
    # 驗證
    assert len(vulnerabilities) == 1  # 應該有一個記錄
    assert vuln.scan_status == 'success'
    assert vuln.vulnerability_count == 0
```

**結果**：✅ 通過

#### 測試 2：CSV 產生邏輯
```python
def test_csv_generation():
    # 執行掃描並產生 CSV
    success, csv_path = manager.scan_from_prompt_function_level(...)
    
    # 讀取 CSV
    with open(csv_path) as f:
        rows = list(csv.DictReader(f))
    
    # 驗證 Semgrep 記錄
    for row in rows:
        if row['掃描器'] == 'semgrep':
            assert row['掃描狀態'] == 'success'
            assert row['漏洞數量'] == '0'
```

**結果**：✅ 通過

### 實際驗證

**修復前的 CSV：**
```csv
輪數,行號,檔案名稱_函式名稱,函式起始行,函式結束行,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
1,1,airflow-core/src/airflow/models/dagbag.py_generate_md5_hash(),,,,,semgrep,,,,failed,No scan results found for semgrep
```

**修復後的 CSV：**
```csv
輪數,行號,檔案名稱_函式名稱,函式起始行,函式結束行,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
1,1,airflow-core/src/airflow/models/dagbag.py_generate_md5_hash(),,,0,,semgrep,,,,success,
```

**對比**：
- ✅ 掃描狀態：`failed` → `success`
- ✅ 漏洞數量：空 → `0`
- ✅ 失敗原因：`No scan results found` → 空

## 📊 影響範圍

### 受益的情況
1. ✅ 掃描成功但沒有發現漏洞的檔案
2. ✅ 程式碼本身沒有安全問題的情況
3. ✅ 正確反映掃描狀態，避免誤報

### 不受影響的情況
1. ✅ 發現漏洞的情況（照常標記為 success + 漏洞清單）
2. ✅ 掃描失敗的情況（照常標記為 failed + 失敗原因）
3. ✅ JSON 檔案不存在的情況（照常標記為 failed）

### 適用的 CWE
所有使用 Bandit 或 Semgrep 掃描的 CWE 類型：
- CWE-095, CWE-327, CWE-502（Semgrep）
- 其他 Bandit 支援的 CWE

## 📚 相關修復

本次修復與以下之前的修復相關：

1. **Semgrep 規則分割修復**（`SEMGREP_RULE_SPLITTING_FIX.md`）
   - 修復了 Semgrep 無法掃描的問題
   - 確保 JSON 報告能正確產生

2. **掃描狀態資料完整性修復**（`SCAN_STATUS_FIX.md`）
   - 修復了掃描失敗時不創建記錄的問題
   - 本次修復處理相反情況：掃描成功但無漏洞

## 🎯 總結

### 問題
程式無法區分「掃描失敗」和「掃描成功但無漏洞」，將後者誤判為前者。

### 解決方案
在 `_parse_semgrep_results()` 和 `_parse_bandit_results()` 中，當 `errors=[]` 且 `results=[]` 時，創建一個 `scan_status='success'` 且 `vulnerability_count=0` 的記錄。

### 效果
- ✅ 正確識別掃描成功但無漏洞的情況
- ✅ CSV 報告準確反映掃描狀態
- ✅ 避免將安全的程式碼誤報為掃描失敗
- ✅ 完整的測試覆蓋

### 測試
- ✅ 測試 1：Semgrep 解析邏輯 - 通過
- ✅ 測試 2：CSV 產生邏輯 - 通過
- ✅ 實際驗證：修復後 CSV 正確顯示 success

---

**修復日期**：2025-10-26  
**測試狀態**：✅ 所有測試通過  
**文檔版本**：1.0
