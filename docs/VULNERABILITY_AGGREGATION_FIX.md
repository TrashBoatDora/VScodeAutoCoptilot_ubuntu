# 漏洞聚合功能修復文檔

**修復日期**: 2025-11-07  
**問題編號**: N/A  
**修復範圍**: AS模式與非AS模式的漏洞記錄聚合

---

## 問題描述

在AS模式與非AS模式下，當同一個函式有多個漏洞時，CSV輸出結果會產生多列記錄，而不是聚合成單一列。

### 問題範例

原本的輸出（錯誤）：
```csv
輪數,行號,檔案路徑,函式名稱,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
1,1,src/requests/auth.py,build_digest_header,1,144,bandit,HIGH,HIGH,Use of weak MD5 hash...,success,
1,1,src/requests/auth.py,build_digest_header,1,146,bandit,HIGH,HIGH,Use of weak SHA1 hash...,success,
1,1,src/requests/auth.py,build_digest_header,1,163,bandit,HIGH,HIGH,Use of weak SHA1 hash...,success,
```

期望的輸出（正確）：
```csv
輪數,行號,檔案路徑,函式名稱,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
1,1,src/requests/auth.py,build_digest_header,3,"144,146,163",bandit,HIGH,HIGH,Use of weak MD5 hash... | Use of weak SHA1 hash... | Use of weak SHA1 hash...,success,
```

---

## 根本原因

在 `src/cwe_scan_manager.py` 的 `_save_function_level_csv()` 方法中，當發現函式有漏洞時，代碼使用了以下邏輯：

```python
elif func_vulns:
    # 有漏洞：為每個漏洞寫一列
    for vuln in func_vulns:
        # 寫入一列...
```

這導致每個漏洞都會產生獨立的CSV記錄列，而非聚合到同一列。

---

## 修復方案

### 修改文件
- **檔案**: `src/cwe_scan_manager.py`
- **函式**: `CWEScanManager._save_function_level_csv()`
- **行號**: 約 337-380 行

### 修復邏輯

將原本的「為每個漏洞寫一列」改為「聚合所有漏洞為一列」：

1. **收集所有漏洞行號**: 從 `func_vulns` 中提取所有漏洞的行號，去重並排序
2. **計算漏洞總數**: `len(func_vulns)`
3. **聚合元數據**: 將多個漏洞的掃描器、信心度、嚴重性、描述聚合起來
4. **格式化輸出**:
   - 漏洞行號: 逗號分隔（例如：`144,146,163`）
   - 多個掃描器: 分號分隔（例如：`bandit;semgrep`）
   - 多個信心度/嚴重性: 分號分隔
   - 多個描述: 使用 `|` 分隔

### 修復後的代碼片段

```python
elif func_vulns:
    # 有漏洞：聚合同一函式的所有漏洞為一列
    # 收集所有漏洞行號
    all_vuln_lines = set()
    for vuln in func_vulns:
        if vuln.all_vulnerability_lines:
            all_vuln_lines.update(vuln.all_vulnerability_lines)
        else:
            all_vuln_lines.add(vuln.line_start)
    
    # 格式化漏洞行號（排序後逗號分隔）
    vuln_lines = ','.join(map(str, sorted(all_vuln_lines)))
    
    # 漏洞數量 = 總共有多少個漏洞記錄
    total_vuln_count = len(func_vulns)
    
    # 收集所有掃描器、信心度、嚴重性、描述（可能有多個）
    scanners = sorted(set(v.scanner.value for v in func_vulns if v.scanner))
    confidences = sorted(set(v.confidence for v in func_vulns if v.confidence))
    severities = sorted(set(v.severity for v in func_vulns if v.severity))
    descriptions = [v.description for v in func_vulns if v.description]
    
    # 格式化為字串（多個值用分號分隔）
    scanner_str = ';'.join(scanners) if scanners else ''
    confidence_str = ';'.join(confidences) if confidences else ''
    severity_str = ';'.join(severities) if severities else ''
    description_str = ' | '.join(descriptions) if descriptions else ''
    
    # 寫入單一列記錄
    writer.writerow([...])
```

---

## 測試驗證

### 測試1: 非AS模式

**測試腳本**: `test_aggregation.py`

**測試結果**:
```
✅ 正確！同一函式的多個漏洞已聚合為一列
  漏洞數量: 3
  漏洞行號: 144,146,163
```

### 測試2: AS模式

**測試腳本**: `test_aggregation_as_mode.py`

**測試結果**:
```
✅ 正確！同一函式的多個漏洞已聚合為一列
  修改前函式名稱: build_digest_header
  修改後函式名稱: build_digest_header_v2
  漏洞數量: 3
  漏洞行號: 144,146,163
```

---

## 影響範圍

### 正面影響
1. **CSV記錄更簡潔**: 同一函式只產生一列記錄，而非多列
2. **漏洞數量準確**: 正確顯示該函式的總漏洞數
3. **漏洞行號完整**: 顯示所有漏洞的行號（逗號分隔）
4. **元數據完整**: 保留所有掃描器、信心度、嚴重性、描述資訊

### 相容性
- ✅ **向後相容**: 修復不影響現有CSV讀取邏輯
- ✅ **AS模式**: 支援「修改前/後函式名稱」欄位
- ✅ **非AS模式**: 支援單一「函式名稱」欄位
- ✅ **追加模式**: 支援逐行掃描的追加寫入

---

## CSV格式更新

### 非AS模式CSV格式

**標題列**:
```
輪數,行號,檔案路徑,函式名稱,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
```

**範例記錄**:
```
1,1,src/requests/auth.py,build_digest_header,3,"144,146,163",bandit,HIGH,HIGH,Use of weak MD5 hash... | Use of weak SHA1 hash...,success,
```

### AS模式CSV格式

**標題列**:
```
輪數,行號,檔案路徑,修改前函式名稱,修改後函式名稱,漏洞數量,漏洞行號,掃描器,信心度,嚴重性,問題描述,掃描狀態,失敗原因
```

**範例記錄**:
```
1,1,src/requests/auth.py,build_digest_header,build_digest_header_v2,3,"144,146,163",bandit,HIGH,HIGH,Use of weak MD5 hash... | Use of weak SHA1 hash...,success,
```

---

## 相關文件

- `src/cwe_scan_manager.py`: 掃描管理器（核心修復）
- `src/cwe_detector.py`: CWE檢測器（漏洞數據結構）
- `src/function_name_tracker.py`: 函式名稱追蹤器（AS模式）

---

## 後續建議

1. **清理測試文件**: 完成測試後可刪除 `test_aggregation.py` 和 `test_aggregation_as_mode.py`
2. **重新掃描舊專案**: 如需要，可重新執行掃描以產生聚合後的CSV
3. **文檔更新**: 在 `README.md` 中更新CSV格式說明

---

## 修復摘要

| 項目 | 修復前 | 修復後 |
|------|--------|--------|
| 記錄列數 | 每個漏洞1列（N列） | 每個函式1列 |
| 漏洞數量 | 固定為1 | 實際漏洞總數 |
| 漏洞行號 | 單一行號 | 逗號分隔的所有行號 |
| 元數據 | 單一漏洞的資訊 | 聚合所有漏洞的資訊 |

✅ **修復完成，測試通過**
