# -*- coding: utf-8 -*-
"""
å°ˆæ¡ˆé¸æ“‡å™¨ UI - è®“ä½¿ç”¨è€…é¸æ“‡è¦è™•ç†çš„å°ˆæ¡ˆ
"""

import tkinter as tk
from tkinter import ttk, messagebox
from pathlib import Path
from typing import List, Set, Tuple
import shutil
from datetime import datetime

from src.logger import get_logger

logger = get_logger("ProjectSelectorUI")


class ProjectSelectorUI:
    """å°ˆæ¡ˆé¸æ“‡å™¨ä»‹é¢"""
    
    def __init__(self, projects_dir: Path):
        """
        åˆå§‹åŒ–å°ˆæ¡ˆé¸æ“‡å™¨
        
        Args:
            projects_dir: å°ˆæ¡ˆç›®éŒ„è·¯å¾‘
        """
        self.projects_dir = Path(projects_dir)
        self.root = tk.Tk()
        self.root.title("å°ˆæ¡ˆé¸æ“‡å™¨")
        self.root.geometry("700x600")
        self.root.resizable(True, True)
        
        # è¨­å®šé—œé–‰äº‹ä»¶è™•ç†
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        self.cancelled = False
        
        # å„²å­˜é¸æ“‡çµæœ
        self.selected_projects: Set[str] = set()
        self.clean_history = True  # é¸æ“‡å°ˆæ¡ˆå³æ¸…ç†æ­·å²è¨˜éŒ„ï¼ˆå›ºå®šç‚º Trueï¼‰
        
        # æƒæå°ˆæ¡ˆ
        self.available_projects = self._scan_projects()
        
        # å»ºç«‹ UI
        self.create_widgets()
        
    def _scan_projects(self) -> List[dict]:
        """
        æƒæ projects ç›®éŒ„ä¸‹çš„æ‰€æœ‰å°ˆæ¡ˆ
        
        Returns:
            List[dict]: å°ˆæ¡ˆè³‡è¨Šåˆ—è¡¨
        """
        projects = []
        
        if not self.projects_dir.exists():
            logger.warning(f"å°ˆæ¡ˆç›®éŒ„ä¸å­˜åœ¨: {self.projects_dir}")
            return projects
        
        for item in self.projects_dir.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                # æª¢æŸ¥æ˜¯å¦æœ‰ prompt.txt
                has_prompt = (item / "prompt.txt").exists()
                
                # è¨ˆç®—æª”æ¡ˆæ•¸é‡
                file_count = len([f for f in item.rglob('*') if f.is_file()])
                
                # æª¢æŸ¥æ˜¯å¦æœ‰åŸ·è¡Œè¨˜éŒ„
                has_execution_log = self._check_execution_history(item.name)
                
                projects.append({
                    'name': item.name,
                    'path': item,
                    'has_prompt': has_prompt,
                    'file_count': file_count,
                    'has_history': has_execution_log
                })
        
        # æŒ‰åç¨±æ’åº
        projects.sort(key=lambda x: x['name'])
        
        logger.info(f"æƒæåˆ° {len(projects)} å€‹å°ˆæ¡ˆ")
        return projects
    
    def _check_execution_history(self, project_name: str) -> bool:
        """
        æª¢æŸ¥å°ˆæ¡ˆæ˜¯å¦æœ‰åŸ·è¡Œæ­·å²è¨˜éŒ„
        
        Args:
            project_name: å°ˆæ¡ˆåç¨±
            
        Returns:
            bool: æ˜¯å¦æœ‰åŸ·è¡Œè¨˜éŒ„
        """
        script_root = self.projects_dir.parent
        
        # æª¢æŸ¥å„ç¨®å¯èƒ½çš„è¨˜éŒ„ä½ç½®
        locations = [
            script_root / "ExecutionResult" / "Success" / project_name,
            script_root / "ExecutionResult" / "AutomationLog" / f"{project_name}*.txt",
            script_root / "ExecutionResult" / "AutomationReport",
            script_root / "CWE_Result",
            script_root / "cwe_scan_results"
        ]
        
        for location in locations:
            if location.exists():
                if location.is_dir() and any(location.iterdir()):
                    return True
                elif location.is_file():
                    return True
        
        return False
    
    def create_widgets(self):
        """å»ºç«‹ UI å…ƒä»¶"""
        # ä¸»æ¨™é¡Œ
        title_frame = ttk.Frame(self.root)
        title_frame.pack(fill="x", padx=20, pady=15)
        
        title_label = tk.Label(
            title_frame,
            text="é¸æ“‡è¦è™•ç†çš„å°ˆæ¡ˆ",
            font=("Arial", 16, "bold")
        )
        title_label.pack()
        
        subtitle_label = tk.Label(
            title_frame,
            text=f"å¾ {len(self.available_projects)} å€‹å¯ç”¨å°ˆæ¡ˆä¸­é¸æ“‡",
            font=("Arial", 10),
            fg="gray"
        )
        subtitle_label.pack(pady=(5, 0))
        
        # èªªæ˜æ–‡å­—
        info_frame = ttk.LabelFrame(self.root, text="èªªæ˜", padding=10)
        info_frame.pack(fill="x", padx=20, pady=(0, 10))
        
        info_text = (
            "â€¢ å‹¾é¸è¦åŸ·è¡Œè‡ªå‹•åŒ–è…³æœ¬çš„å°ˆæ¡ˆ\n"
            "â€¢ é¸å®šçš„å°ˆæ¡ˆå°‡è‡ªå‹•æ¸…é™¤å…ˆå‰çš„åŸ·è¡Œè¨˜éŒ„\n"
            "â€¢ æœªé¸æ“‡çš„å°ˆæ¡ˆå°‡è¢«è·³éï¼Œä¸æœƒè™•ç†"
        )
        info_label = tk.Label(info_frame, text=info_text, justify="left")
        info_label.pack()
        
        # å°ˆæ¡ˆåˆ—è¡¨å€åŸŸï¼ˆå¯æ»¾å‹•ï¼‰
        list_frame = ttk.LabelFrame(self.root, text="å¯ç”¨å°ˆæ¡ˆ", padding=10)
        list_frame.pack(fill="both", expand=True, padx=20, pady=(0, 10))
        
        # å‰µå»ºå¯æ»¾å‹•çš„æ¡†æ¶
        self.create_scrollable_list(list_frame)
        
        # å¿«é€Ÿé¸æ“‡æŒ‰éˆ•
        quick_select_frame = ttk.Frame(self.root)
        quick_select_frame.pack(fill="x", padx=20, pady=(0, 10))
        
        ttk.Button(
            quick_select_frame,
            text="å…¨é¸",
            command=self.select_all,
            width=10
        ).pack(side="left", padx=5)
        
        ttk.Button(
            quick_select_frame,
            text="å…¨ä¸é¸",
            command=self.deselect_all,
            width=10
        ).pack(side="left", padx=5)
        
        ttk.Button(
            quick_select_frame,
            text="åé¸",
            command=self.invert_selection,
            width=10
        ).pack(side="left", padx=5)
        
        # åº•éƒ¨æŒ‰éˆ•
        button_frame = ttk.Frame(self.root)
        button_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        # çµ±è¨ˆè³‡è¨Š
        self.stats_label = tk.Label(
            button_frame,
            text="å·²é¸æ“‡: 0 å€‹å°ˆæ¡ˆ",
            font=("Arial", 10)
        )
        self.stats_label.pack(side="left")
        
        # ç¢ºèªå’Œå–æ¶ˆæŒ‰éˆ•
        ttk.Button(
            button_frame,
            text="å–æ¶ˆ",
            command=self.on_cancel,
            width=12
        ).pack(side="right", padx=(5, 0))
        
        ttk.Button(
            button_frame,
            text="ç¢ºèª",
            command=self.on_confirm,
            width=12
        ).pack(side="right")
    
    def create_scrollable_list(self, parent):
        """å‰µå»ºå¯æ»¾å‹•çš„å°ˆæ¡ˆåˆ—è¡¨"""
        # å‰µå»º Canvas å’Œ Scrollbar
        canvas = tk.Canvas(parent, highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # ç¶å®šæ»¾è¼ªäº‹ä»¶
        canvas.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1 * (e.delta / 120)), "units"))
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # å„²å­˜å‹¾é¸æ¡†è®Šæ•¸
        self.project_vars = {}
        
        # å‰µå»ºå°ˆæ¡ˆåˆ—è¡¨
        if not self.available_projects:
            no_project_label = tk.Label(
                scrollable_frame,
                text="æ²’æœ‰å¯ç”¨çš„å°ˆæ¡ˆ",
                font=("Arial", 12),
                fg="gray"
            )
            no_project_label.pack(pady=50)
        else:
            for project in self.available_projects:
                self._create_project_item(scrollable_frame, project)
    
    def _create_project_item(self, parent, project: dict):
        """å‰µå»ºå–®å€‹å°ˆæ¡ˆé …ç›®"""
        item_frame = ttk.Frame(parent)
        item_frame.pack(fill="x", padx=5, pady=3)
        
        # å‹¾é¸æ¡†
        var = tk.BooleanVar(value=False)
        self.project_vars[project['name']] = var
        
        # ç¶å®šè®Šæ•¸è®ŠåŒ–äº‹ä»¶ï¼ˆä½¿ç”¨å‚³çµ± trace æ–¹æ³•ï¼‰
        var.trace('w', lambda *args: self.update_stats())
        
        checkbox = ttk.Checkbutton(
            item_frame,
            variable=var
        )
        checkbox.pack(side="left", padx=(0, 10))
        
        # å°ˆæ¡ˆè³‡è¨Š
        info_frame = ttk.Frame(item_frame)
        info_frame.pack(side="left", fill="x", expand=True)
        
        # å°ˆæ¡ˆåç¨±
        name_label = tk.Label(
            info_frame,
            text=project['name'],
            font=("Arial", 10, "bold"),
            anchor="w"
        )
        name_label.pack(fill="x")
        
        # è©³ç´°è³‡è¨Š
        details = []
        if project['has_prompt']:
            details.append("âœ“ Prompt")
        else:
            details.append("âœ— ç„¡ Prompt")
        
        details.append(f"{project['file_count']} å€‹æª”æ¡ˆ")
        
        if project['has_history']:
            details.append("ğŸ“‹ æœ‰åŸ·è¡Œè¨˜éŒ„")
        
        detail_text = " | ".join(details)
        detail_label = tk.Label(
            info_frame,
            text=detail_text,
            font=("Arial", 9),
            fg="gray",
            anchor="w"
        )
        detail_label.pack(fill="x")
    
    def update_stats(self):
        """æ›´æ–°çµ±è¨ˆè³‡è¨Š"""
        selected_count = sum(1 for var in self.project_vars.values() if var.get())
        text = f"å·²é¸æ“‡: {selected_count} å€‹å°ˆæ¡ˆ"
        self.stats_label.config(text=text)
        self.stats_label.update_idletasks()  # å¼·åˆ¶æ›´æ–° UI
        logger.debug(f"çµ±è¨ˆæ›´æ–°: {text}")
    
    def select_all(self):
        """å…¨é¸"""
        for var in self.project_vars.values():
            var.set(True)
        self.update_stats()
    
    def deselect_all(self):
        """å…¨ä¸é¸"""
        for var in self.project_vars.values():
            var.set(False)
        self.update_stats()
    
    def invert_selection(self):
        """åé¸"""
        for var in self.project_vars.values():
            var.set(not var.get())
        self.update_stats()
    
    def on_confirm(self):
        """ç¢ºèªæŒ‰éˆ•äº‹ä»¶"""
        # æ”¶é›†é¸ä¸­çš„å°ˆæ¡ˆ
        self.selected_projects = {
            name for name, var in self.project_vars.items() if var.get()
        }
        
        # èª¿è©¦è¼¸å‡º
        logger.info(f"æ”¶é›†åˆ°çš„å°ˆæ¡ˆ: {self.selected_projects}")
        logger.info(f"å°ˆæ¡ˆè®Šæ•¸ç‹€æ…‹: {[(name, var.get()) for name, var in self.project_vars.items()]}")
        
        if not self.selected_projects:
            messagebox.showwarning(
                "æœªé¸æ“‡å°ˆæ¡ˆ",
                "è«‹è‡³å°‘é¸æ“‡ä¸€å€‹å°ˆæ¡ˆï¼"
            )
            return
        
        # ç¢ºèªå°è©±æ¡†
        message = (
            f"æ‚¨é¸æ“‡äº† {len(self.selected_projects)} å€‹å°ˆæ¡ˆã€‚\n\n"
            f"ç¢ºèªè¦è™•ç†é€™äº›å°ˆæ¡ˆå—ï¼Ÿ\n\n"
            f"âš ï¸  å°‡æœƒæ¸…é™¤é€™äº›å°ˆæ¡ˆçš„åŸ·è¡Œè¨˜éŒ„å’Œçµæœï¼"
        )
        
        if messagebox.askyesno("ç¢ºèªé¸æ“‡", message):
            self.clean_history = True  # å›ºå®šç‚º True
            self.cancelled = False
            logger.info(f"ä½¿ç”¨è€…ç¢ºèªé¸æ“‡: {self.selected_projects}")
            self.root.destroy()
        else:
            logger.info("ä½¿ç”¨è€…å–æ¶ˆç¢ºèª")
    
    def on_cancel(self):
        """å–æ¶ˆæŒ‰éˆ•äº‹ä»¶"""
        self.cancelled = True
        self.selected_projects = set()
        self.root.destroy()
    
    def on_close(self):
        """è¦–çª—é—œé–‰äº‹ä»¶"""
        self.on_cancel()
    
    def show(self) -> Tuple[Set[str], bool, bool]:
        """
        é¡¯ç¤ºå°è©±æ¡†ä¸¦ç­‰å¾…ä½¿ç”¨è€…æ“ä½œ
        
        Returns:
            Tuple: (é¸ä¸­çš„å°ˆæ¡ˆé›†åˆ, æ˜¯å¦æ¸…ç†æ­·å², æ˜¯å¦è¢«å–æ¶ˆ)
        """
        self.root.mainloop()
        return self.selected_projects, self.clean_history, self.cancelled


def show_project_selector(projects_dir: Path = None) -> Tuple[Set[str], bool, bool]:
    """
    é¡¯ç¤ºå°ˆæ¡ˆé¸æ“‡å™¨å°è©±æ¡†
    
    Args:
        projects_dir: å°ˆæ¡ˆç›®éŒ„è·¯å¾‘ï¼Œé è¨­ç‚º ./projects
        
    Returns:
        Tuple: (é¸ä¸­çš„å°ˆæ¡ˆé›†åˆ, æ˜¯å¦æ¸…ç†æ­·å², æ˜¯å¦è¢«å–æ¶ˆ)
    """
    if projects_dir is None:
        projects_dir = Path(__file__).parent.parent / "projects"
    
    ui = ProjectSelectorUI(projects_dir)
    return ui.show()


if __name__ == "__main__":
    # æ¸¬è©¦ç”¨
    selected, clean, cancelled = show_project_selector()
    
    if not cancelled:
        print(f"\né¸ä¸­çš„å°ˆæ¡ˆ: {selected}")
        print(f"æ¸…ç†æ­·å²: {clean}")
    else:
        print("\nå·²å–æ¶ˆ")
